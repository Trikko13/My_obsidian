Нормализация - уменьшение избыточности в данных и повышение целостности. Подразумевает разбиение таблиц и установление четких зависимостей между ними (ID). Однако высокая нормализация - усложняет запросы из за джоинов.
Денормализация - объединяет данные для повышение скорости обработки, но вносит избыточность

Существует 3 основные Normal forms (1NF,2NF,3NF)

1NF. У каждой записи есть PK и все атрибуты содержат неделимые атомарные значения.
2NF. Таблица удовлетворяет 1NF, и все неключевые атрибуты зависят от первичного ключа. Тут идет устранение частичных зависимостей, когда неключевые атрибуты зависят от части составного ключа
3NF. Таблица удовлетворяет 2NF, и все неключевые атрибуты независимы друг от друга. Устранение транзитивных зависимостей, когда неключевые атрибуты зависят друг от друга.

### Пример

Рассмотрим простой пример информационной системы, хранящей данные о заказах клиентов.

#### Денормализованная таблица (до нормализации):

| OrderID | CustomerName | CustomerAddress | ProductName | ProductPrice | OrderDate  | Quantity |
| ------- | ------------ | --------------- | ----------- | ------------ | ---------- | -------- |
| 1       | John Smith   | 123 Elm St      | Laptop      | 1000         | 2024-09-20 | 2        |
| 2       | Jane Doe     | 456 Oak St      | Smartphone  | 600          | 2024-09-21 | 1        |
| 3       | John Smith   | 123 Elm St      | Laptop      | 1000         | 2024-09-22 | 1        |
### 1 NF 
 На уровне **первой нормальной формы (1NF)** акцент делается исключительно на структурировании данных, чтобы таблица удовлетворяла следующим требованиям:

---

### **1NF: Основные принципы**

1. **Атомарность данных:**
    
    - Каждое значение в таблице должно быть атомарным, то есть содержать одно значение, а не массив, список или сложную структуру.
    - Пример:
        
        |ID|Products|
        |---|---|
        |1|Apple, Orange|
        |**Не соответствует 1NF** → разделяем:||
        |ID|Product|
        |-----|-----------------|
        |1|Apple|
        |1|Orange|
        
2. **Повторяющиеся группы:**
    
    - В таблице не должно быть колонок, которые дублируют друг друга.
    - Пример:
        
        |ID|Product1|Product2|
        |---|---|---|
        |1|Apple|Orange|
        |**Не соответствует 1NF** → объединяем в одну колонку:|||
        |ID|Product||
        |-----|-----------------||
        |1|Apple||
        |1|Orange||
        
3. **Табличный вид данных:**
    
    - Строки и столбцы упорядочены, каждая колонка соответствует атрибуту, а строка — записи.

---

### **Ключи на уровне 1NF**

- **На этапе 1NF не обязательно определять первичные ключи.**
    - Основная задача на этом этапе — привести данные к **табличному виду** и устранить структурные проблемы, такие как массивы или повторяющиеся группы.

---

### Пример для иллюстрации

#### Таблица **до приведения к 1NF**:

|ID|Name|Products|
|---|---|---|
|1|John Smith|Apple, Orange|
|2|Jane Doe|Banana, Grape|

- **Проблемы:**
    - Колонка `Products` содержит массив (список).

#### Таблица **после приведения к 1NF**:

|ID|Name|Product|
|---|---|---|
|1|John Smith|Apple|
|1|John Smith|Orange|
|2|Jane Doe|Banana|
|2|Jane Doe|Grape|

---

### **Вывод**

- **Цель 1NF**: Привести данные в табличный вид и устранить массивы, повторяющиеся группы и неатомарные значения.
- **Ключи:**
    - На этапе 1NF **ключи могут не быть определены**, но данные уже должны быть готовы для их постановки.
    - Ключи начинают играть роль на уровнях **2NF** и выше, где проверяется функциональная зависимость атрибутов.
### 2 NF 
В второй нормальной форме исключаются частичные зависимости. В таблице заказов все неключевые зависимости должны зависеть от полного первичного ключе (у нас комбинация OrderID, ProductID)
У нас нет частичных зависимостей , так как все данные зависят от ключа. Таблицы клиентов и продуктов уже нормализованы.

### 3 NF
В третьей исключаем транзитивные зависимости. Например, если бы мы хранили город в таблице заказов, который можно получить из адреса клиента, то это была бы транзитивная зависимость. В данном случае таких зависимостей нет


**Результат**.  
* В целом мы применили все 3NF, однако нам хватило и самой первой нормальной формы для удовлетворения требований. 
* Получили минимум дубликатов за счет создания отдельных таблиц
* Целостность сохранена. Например изменение адреса производится только в одном месте и все ключи подтягиваются независимо от названия.
* 
__

Нормальное видео ➜ [1НФ, 2НФ, 3НФ нормальные формы](https://www.youtube.com/watch?v=zwQzL80U51c)

Читать ➜ [Хабр статья про нормальные формы](https://habr.com/ru/articles/254773)

Скачать PDF ➜ [Конспект про нормальные формы](https://github.com/Trikko13/HalltapeRoadmapDE/blob/main/files/normal_tables.pdf)

__


### Что такое **потенциальный ключ**, **неполный ключ** и **неключевой атрибут**?

1. **Потенциальный ключ:**
    
    - Это один или несколько атрибутов, которые могут однозначно идентифицировать каждую строку в таблице.
    - Пример:  
        В таблице `orders`:
        - `order_id` — потенциальный ключ, если он уникален.
        - `(order_id, product_id)` — потенциальный составной ключ, если `order_id` и `product_id` вместе идентифицируют строки.
2. **Неполный ключ:**
    
    - Это часть составного ключа, которая сама по себе **не может однозначно определить строку**.
    - Пример:  
        Если `(order_id, product_id)` — составной ключ, то:
        - `order_id` или `product_id` по отдельности — неполные ключи.
3. **Неключевой атрибут:**
    
    - Это атрибут, который не входит в состав потенциального ключа.
    - Пример:  
        В таблице заказов:
        - `(order_id, product_id)` — составной ключ.
        - `quantity` — неключевой атрибут.
### **Ключевое отличие**

- Потенциальный ключ используется для **идентификации строк**.
- Неключевой атрибут предоставляет **дополнительную информацию** о строке, но не определяет её уникальность.

### Понятие **полной функциональной зависимости**

**Полная функциональная зависимость** — это зависимость атрибута от **всего потенциального ключа**, а не только от его части.

- Если зависимость от только части ключа, то она называется **частичной зависимостью**.

**Пример полной зависимости:**

- Таблица с заказами:
    - `(order_id, product_id)` → `quantity`  
        Здесь `quantity` полностью зависит от составного ключа `(order_id, product_id)`, потому что:
        - Только `order_id` или только `product_id` недостаточно, чтобы определить `quantity`.

**Пример частичной зависимости:**

- `(order_id, product_id)` → `customer_name`  
    Здесь `customer_name` зависит только от `order_id` (части ключа), потому что `order_id` однозначно определяет заказчика.



## **1. Первая нормальная форма (1NF):**

Как вы правильно сказали:

- В 1NF каждое поле (атрибут) в строке (кортеж) должно содержать только одно значение.
- Данные должны быть представлены в табличном виде, а каждая колонка должна содержать атомарные значения (одно значение, а не список, массив или вложенную структуру).

---

## **2. Вторая нормальная форма (2NF):**

**Определение:**

- Таблица находится во второй нормальной форме, если:
    1. Она уже в **1NF**.
    2. Каждый неключевой атрибут зависит от **всего потенциального ключа**, а не от части этого ключа.

---

### Что такое **функциональная зависимость**?

**Функциональная зависимость** описывает связь между атрибутами:

- Если значение одного атрибута (или нескольких) однозначно определяет значение другого атрибута, говорят, что второй атрибут **функционально зависит** от первого.

**Пример функциональной зависимости:**

- В таблице студентов:
    - Атрибут `student_id` однозначно определяет `student_name`.
    - Это записывают так: `student_id → student_name`.

---

### Что такое **потенциальный ключ**, **неполный ключ** и **неключевой атрибут**?

1. **Потенциальный ключ:**
    
    - Это один или несколько атрибутов, которые могут однозначно идентифицировать каждую строку в таблице.
    - Пример:  
        В таблице `orders`:
        - `order_id` — потенциальный ключ, если он уникален.
        - `(order_id, product_id)` — потенциальный составной ключ, если `order_id` и `product_id` вместе идентифицируют строки.
2. **Неполный ключ:**
    
    - Это часть составного ключа, которая сама по себе **не может однозначно определить строку**.
    - Пример:  
        Если `(order_id, product_id)` — составной ключ, то:
        - `order_id` или `product_id` по отдельности — неполные ключи.
3. **Неключевой атрибут:**
    
    - Это атрибут, который не входит в состав потенциального ключа.
    - Пример:  
        В таблице заказов:
        - `(order_id, product_id)` — составной ключ.
        - `quantity` — неключевой атрибут.

---

### Понятие **полной функциональной зависимости**

**Полная функциональная зависимость** — это зависимость атрибута от **всего потенциального ключа**, а не только от его части.

- Если зависимость от только части ключа, то она называется **частичной зависимостью**.

**Пример полной зависимости:**

- Таблица с заказами:
    - `(order_id, product_id)` → `quantity`  
        Здесь `quantity` полностью зависит от составного ключа `(order_id, product_id)`, потому что:
        - Только `order_id` или только `product_id` недостаточно, чтобы определить `quantity`.

**Пример частичной зависимости:**

- `(order_id, product_id)` → `customer_name`  
    Здесь `customer_name` зависит только от `order_id` (части ключа), потому что `order_id` однозначно определяет заказчика.

---

## **3. Приведение к 2NF**

Чтобы таблица соответствовала 2NF:

1. Она должна быть в **1NF**.
2. Нужно устранить **частичные зависимости** — когда неключевой атрибут зависит от части составного ключа.

### Пример:

#### Исходная таблица:

|**order_id**|**product_id**|**customer_name**|**quantity**|
|---|---|---|---|
|1|101|John Smith|2|
|1|102|John Smith|1|
|2|101|Jane Doe|4|

- Потенциальный ключ: `(order_id, product_id)`.
- Проблема:
    - `customer_name` зависит только от `order_id` (частичная зависимость).

#### Приведение к 2NF:

Разделим таблицу на две:

1. Таблица заказов (зависимость `order_id → customer_name`):
    
    |**order_id**|**customer_name**|
    |---|---|
    |1|John Smith|
    |2|Jane Doe|
    
2. Таблица товаров в заказе (зависимость `(order_id, product_id) → quantity`):
    
    |**order_id**|**product_id**|**quantity**|
    |---|---|---|
    |1|101|2|
    |1|102|1|
    |2|101|4|
    

Теперь все неключевые атрибуты зависят от **всего потенциального ключа** в каждой таблице.

---

### Итог:

- **Полная зависимость:** Неключевой атрибут зависит от **всего составного ключа**, а не его части.
- **Частичная зависимость:** Неключевой атрибут зависит только от части составного ключа.
- Приведение к 2NF устраняет частичные зависимости, разбивая таблицу на несколько меньших, чтобы каждая зависимость стала полной.

#### Приведение к 2NF:

Все атрибуты зависят только от первичного ключа, а не от других атрибутов

- Таблица находится в **3NF**, если:
    1. Она уже в **2NF**.
    2. Все неключевые атрибуты зависят **только от первичного ключа** и **не зависят друг от друга** (т.е. отсутствуют транзитивные зависимости).

В вашем случае:

- Все атрибуты в каждой таблице зависят только от своих ключей.
- Транзитивные зависимости отсутствуют, так как:
    - Например, в таблице студентов: `group_id` зависит от `student_id`, но больше ничего.
    - В других таблицах аналогично — атрибуты зависят только от ключа (`group_id`, `faculty_id`).

**Вывод:** Ваши таблицы действительно удовлетворяют **третьей нормальной форме (3NF)**.