
!!
**Перейди в конец файла, там основное и упрощенное**
!!

- **Создай репозиторий**:
    - Создай репозиторий на GitHub, GitLab или другом сервисе.
    - Инициализируй локальный репозиторий командой `git init` в корневой папке проекта.
    - Добавь удалённый репозиторий командой `git remote add origin https://github.com/Trikko13/retail_sales.git.
- **Подготовь проект для синхронизации**:
    
    - Добавь файлы в индекс: `git add .`
    - Зафиксируй изменения: `git commit -m "Первоначальный коммит"`
    - Запушь изменения на удалённый репозиторий: `git push -u origin main`
- **Синхронизация на других устройствах**:
    
    - Клонируй репозиторий на ноутбуке: `git clone <https://github.com/Trikko13/retail_sales.git>`
    - Для синхронизации используй команды `git pull` и `git push`.

Варианты отката неудачного коммита:

Чтобы откатить локальный репозиторий на предыдущий коммит, выполните следующие шаги:

### Варианты отката:

1. **`git reset --soft HEAD~1`**:
    
    - **Откатывает на предыдущий коммит**, сохраняя изменения в рабочей директории и индексе (изменения будут добавлены для следующего коммита).
    - Команда:
        
        bash
        
        Копировать код
        
        `git reset --soft HEAD~1`
        
    - Используйте это, если вы хотите отменить коммит, но сохранить изменения в файлах для возможной правки и повторного коммита.
2. **`git reset --mixed HEAD~1`** (по умолчанию):
    
    - **Откатывает на предыдущий коммит**, изменения останутся в рабочей директории, но не будут добавлены в индекс.
    - Команда:
        
        bash
        
        Копировать код
        
        `git reset HEAD~1`
        
3. **`git reset --hard HEAD~1`**:
    
    - **Полностью откатывает коммит и изменения**: все изменения будут удалены, и код вернется к состоянию предыдущего коммита.
    - **Предупреждение**: Используйте с осторожностью, так как все незакоммиченные изменения будут потеряны.
    - Команда:
        
        bash
        
        Копировать код
        
        `git reset --hard HEAD~1`
        

### Объяснение:

- **`HEAD~1`** указывает на предыдущий коммит относительно текущего `HEAD`.
- Можно использовать конкретный хэш коммита вместо `HEAD~1`, если нужно откатиться к определенному коммиту:
    
    bash
    
    Копировать код
    
    `git reset --hard <commit_hash>`
    

### Проверка состояния репозитория:

После отката убедитесь, что изменения применены, с помощью команды:

bash

Копировать код

`git status`

### Примечание:

Если вы уже отправили коммит в удаленный репозиторий и хотите откатить его локально и в удаленном репозитории, после отката выполните принудительный `push`:

bash

Копировать код

`git push origin main --force`

**Предупреждение**: Принудительный `push` может привести к конфликтам у других пользователей, работающих с этим репозиторием, поэтому используйте его только при необходимости.

## **Основное для начала работы
1. Создаем ключ через терминал  `ssh-keygen`, затем выполняем его показ через `cat /Users/username/.ssh/id_rsa.pub`. Выполняем сохранения ключа на Гите в настройках
2. Скачиваем нужным репозиторий на комп через `git clone` перейдя в папку, где хотим видеть его расположение
3. Смотрим список новых или обновленных файлов на ПК (в прапке с репо) - `git status`
4. Теперь создадим отдельную ветку разработчика, чтобы не засорять контроль версий основной **master** ветки. Для этого указываем в терминале команду с названием ветки: `git checkout -b develop`.
5. Далее переключимся на нее чтобы отныне все изменения и версионность были сохранены лишь в нашей, личной ветке: `git switch develop`.
6. Проверяем что мы реально на develop ветке: `git branch`
7. Далее нужно добавить файлы на индексацию (stage) перед коммитом - `git add .` (точка если все измененные файлы, либо путь к файлу если один)
8. После добавления файлов в индексацию пишет **`git commit -m 'Первый коммит'`**. Таким образом Гит запомнит какие файлы были изменены,кем, и какое сообщение (-m ...)
9. Ну и загрузка. Для того чтобы все выбранные файлы попали на ветку **develop**: `git push origin developer`
10. Когда на ноуте или ПК сделана основная работа - нужно выполнить `git pull` для сохранения изменений на репозиторий и дальнейшего редактирования
11. Есть мысли сделать 2 ветки для Ноута и для ПК , Developer-PC, Developer-Notebook. Чтобы в конце была возможность внести на мастер ветку через `git rebase master` . Таким образом все коммиты с разных машин не будут пересекаться до **слияния** с **master branch** 
12. Если коммиты сделались плохими в какой то версии, можно откатить через `git revert хеш__коммита.`

Важные  команды в видео Влада
https://www.youtube.com/watch?v=XuFaQSW79rM