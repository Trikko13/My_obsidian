*"""1. Работа с аргументами функции*  
*Задание: Напиши функцию process_data, которая принимает неограниченное количество позиционных*  
*и именованных аргументов."""
  
Функция должна складывать все переданные числовые значения.  
Все именованные аргументы должны выводиться как ключ-значение."""  
  
`def greet(name, age):`  
    `print(f"Hello, {name}! You are {age} years old.")`  
  
`greet('Alice', 23) #позиционные аргмуенты: для name - 'Alice', для age - 23`  
`greet(age='Alice', name=23) #именованные - соблюдаем порядок`  

**В Python через args, kwargs мы принимаем любое количество позиционных аргументов.*  

`def process_data(*args, **kwargs):`  
    `print("Positional arguments:", args)`  
    `print("Named arguments:", kwargs)`  
  
`process_data(10,20,30,name='Dataset A', date='2024-10-03')`

`Результат :`
`Positional arguments: (10, 20, 30)`
`Named arguments: {'name': 'Dataset A', 'date': '2024-10-03'}`


### Как планировать код функций исходя из задания

Планирование функции — важный этап, который помогает не усложнить код. Вот несколько шагов, чтобы упростить процесс написания функции.

1. **Понимание задачи и результата**:
    
    - Первым делом прочитай задание несколько раз, чтобы точно понять, какие данные функция должна принимать и какой результат вернуть. Определи:
        - Типы данных на входе (например, числа, строки, списки).
        - Формат результата, который должен возвращаться.
2. **Определение параметров функции**:
    
    - Выбери, какие аргументы будут обязательными, а какие можно сделать необязательными (с использованием `*args`, `**kwargs`).
    - В задачах, где параметры могут изменяться (например, обработка произвольного количества данных), использование `*args` и `**kwargs` поможет сделать функцию более гибкой.
3. **Планирование логики внутри функции**:
    
    - Разбей задачу на простые шаги. Например, если функция должна принимать разные типы аргументов, начни с обработки позиционных аргументов, а потом переходи к именованным.
    - Если нужно выполнять несколько действий, разбей их на этапы, и каждый этап можно выделить в отдельный блок кода или подфункцию. Это сделает код проще и модульнее.
4. **Проверка работы и отладка**:
    
    - Пиши функции с проверками, чтобы на каждом этапе убеждаться, что функция выполняет свои задачи корректно.
    - Можно использовать `print()` для промежуточных значений или тестовые вызовы функции.

