https://habr.com/ru/articles/268983/

Сложные задачи
Карпов 8.
`SELECT user_id,`
       `avg(time_diff)::integer as hours_between_orders`
`FROM   (SELECT user_id,`
               `order_id,`
               `time,`
               `extract(epoch`
        `FROM   (time - lag(time, 1)`
        `OVER (`
        `PARTITION BY user_id`
        `ORDER BY time)))/3600 as time_diff`
        `FROM   user_actions`
        `WHERE  order_id not in (SELECT order_id`
                                `FROM   user_actions`
                                `WHERE  action = 'cancel_order')) t`
`WHERE  time_diff is not null`
`GROUP BY user_id`
`ORDER BY user_id limit 1000`

**Алгоритм решения**
- **Фильтрация отменённых заказов**:
    - Подзапрос сразу отфильтровывает отменённые заказы, что исключает лишние заказы на начальном этапе. Это избавляет от необходимости создавать отдельный CTE.
- **Вычисление `time_diff` с использованием `LAG` и преобразование в часы**:
    - В подзапросе `LAG(time, 1)` создаёт временной сдвиг, где у каждого заказа есть время предыдущего заказа (`prev_time`).
    - `time - lag(time, 1) OVER (...)` даёт разницу между текущим заказом и предыдущим.
    - `EXTRACT(epoch FROM ...) / 3600` переводит разницу в секунды и делит на 3600 для перевода в часы, сразу получая `time_diff` в нужном формате.
- **Условие `WHERE time_diff IS NOT NULL`**:
    - Это ключевой момент: здесь сразу исключаются строки, где `time_diff` `NULL` (то есть строки с первым заказом, у которых нет предыдущего заказа).
    - В результате, нам не нужно добавлять условия или фильтры в основной запрос, чтобы исключить пользователей с одним заказом.
- **Основной запрос с `AVG` и `GROUP BY`**:
    - В основном запросе уже вычисляется среднее значение времени `time_diff` в часах для каждого пользователя.
    - Преобразование в целое число (`::integer`) завершает обработку.
### Как к этому прийти

1. **Понять, что каждый промежуточный шаг должен решать конкретную задачу**:
    - Фильтровать отменённые заказы, посчитать разницу между заказами, затем сгруппировать и усреднить.
2. **Сначала сконцентрироваться на `time_diff`**:
    
    - Важно было понять, что `LAG` сразу решает задачу с предыдущими датами и позволяет легко получить `time_diff` в часах.
3. **Сократить количество подзапросов**:
    
    - В этом решении используется только один подзапрос для расчёта `time_diff`, и этого достаточно для получения среднего значения.

### Почему не получилось сразу

Сложность возникла из-за попытки добавить лишние CTE и условий, что создало дополнительные сложности. Основное отличие правильного решения — в его минимализме, оставлены только нужные шаги без лишних фильтров и проверок.

### Вывод

Лучше всего при таких задачах:

- Сначала максимально просто получить нужные промежуточные значения (например, `time_diff`),
- Потом применять агрегатные функции, минимизируя количество подзапросов и дополнительных условий.

Хорошо, давай углубимся в подход, чтобы сделать его более интуитивным и избегать усложнений в подобных задачах.

### Как структурировать процесс решения задач с оконными функциями

1. **Определи, что нужно получить на каждом этапе**:
    
    - В данном случае ключевой этап — расчёт разницы времени (`time_diff`) для каждого заказа пользователя. Если изначально сконцентрироваться на получении только `time_diff`, становится проще решить остальную часть задачи.
    - В подобных задачах всегда полезно выделить главное, что нужно получить: это может быть разница между строками (как `LAG`), порядковый номер (как `ROW_NUMBER`), или какие-то накопительные суммы.
2. **Минимизируй количество подзапросов и условий**:
    
    - Избегай создания промежуточных CTE (подзапросов), если они добавляют шаги, которые можно выполнить в одном запросе.
    - Например, если сразу рассчитать `time_diff` в основном подзапросе, отпадает необходимость в дополнительных CTE, что делает код более читаемым.
3. **Работай с нужными данными — фильтруй на начальном этапе**:
    
    - Фильтрация отменённых заказов до применения оконных функций, как в решении, — это важный шаг, который исключает лишние строки с самого начала, облегчая работу оконных функций.
    - В задачах, где нужно исключить или отобрать определённые записи, стоит выполнять фильтрацию на уровне подзапроса или сразу в `WHERE` при получении данных, а не в дополнительных условиях в конце.
4. **Обращай внимание на методы округления и приведения типов**:
    
    - Если задаётся конкретный формат для данных, например, целое число, всегда добавляй приведение в нужный тип на этапе, когда получаешь итоговые данные.
    - Как в данном случае, преобразование `AVG(time_diff)` в целое число (`::integer`) делается на последнем этапе, чтобы не усложнять запрос до этого.

### Как избежать запутывания при использовании оконных функций

1. **Работай с простыми шагами**:
    
    - Построй изначально упрощённый запрос, который только выводит `time_diff` и проверяет правильность промежуточных значений.
    - После этого добавь `AVG` и `GROUP BY`, убедившись, что каждый шаг выполняется корректно.
2. **Сконцентрируйся на правильном использовании оконной функции**:
    
    - Например, если цель — вычислить промежуток времени между заказами, используй `LAG`, а если нужно номер заказа — `ROW_NUMBER`.
    - Определи необходимую логику для оконной функции и выбери подходящий метод (`PARTITION BY` для разбиения данных или `ORDER BY` для последовательности внутри групп).
3. **Минимально необходимые условия**:
    
    - Вопросы фильтрации и дополнительных условий часто добавляют сложности, особенно при условии `HAVING COUNT > 1`, которое в твоей задаче стало лишним.
    - При работе с `NULL` и другими условиями всегда проверяй, можно ли решить задачу без дополнительных проверок.

### Заключение

При решении задач с оконными функциями выделяй каждый ключевой шаг, отказывайся от промежуточных данных, которые не нужны, и старайся максимально лаконично подходить к фильтрации и выбору оконных функций. Постепенно это станет автоматическим подходом, и задачи с оконными функциями станут более интуитивными.

## Filter in WIndow fucntions

Если к определению оконной функции добавить предложение `FILTER`, то в окно попадут только те входные строки, для которых условие фильтра будет вычислено как истинное.

При этом предложение `FILTER` допускается только для агрегирующих оконных функций.

В общем виде вся конструкция выглядит так:
`SELECT agg_function(column) FILTER (WHERE [condition]) OVER (...)`
`FROM table`
пример
`SELECT SUM(column_1) FILTER (WHERE column_2 > 100) OVER (PARTITION BY column_3 ORDER BY column_4) AS sum`
`FROM table`