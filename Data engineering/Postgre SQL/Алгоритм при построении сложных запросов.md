### Шаги для понимания алгоритма написания запроса:
Пояснение задачи 14

1. **Четко пойми, что нужно получить:**
    
    - В этом задании нужно собрать статистику по пользователям: количество заказов, средний размер заказа, общая стоимость заказов, средняя, минимальная и максимальная стоимость заказа. Основные таблицы, с которыми ты работаешь, — это `user_actions`, `orders`, и `products`.
2. **Определи ключевые таблицы и связи:**
    - У тебя есть три главные сущности:
        1. **Пользователи (`user_actions`)**: Здесь находится информация о действиях пользователей и о том, какие заказы они сделали.
        2. **Заказы (`orders`)**: Содержит информацию о заказах, в том числе массив с продуктами (поле `product_ids`).
        3. **Продукты (`products`)**: Здесь цены на каждый продукт
**Связи:**

- Таблица `user_actions` связывается с `orders` по `order_id`.
- Таблица `orders` связывается с `products` по `product_id`, так как в заказе может быть несколько продуктов, нужно использовать `unnest()`.
**Разбей задачу на подзадачи:**

- **Фильтрация отменённых заказов**: Тебе нужно исключить отменённые заказы из запроса. Это ключевой этап фильтрации.
- **Счётчики заказов и их параметров**: Необходимо посчитать количество товаров в заказе и их стоимость.

Логика кода:
*внутренний подзапрос 1(t1)*
`(SELECT user_id,`
        `order_id`
 `FROM   user_actions`
 `WHERE  order_id not in (SELECT order_id`
                         `FROM   user_actions`
                         `WHERE  action = 'cancel_order')) t1`
`
* **Задача:** Получить всех пользователей и их заказы, которые **не отменены** (т.е. `action != 'cancel_order'`).

*внутренний подзапрос 2(t2)*
`SELECT user_id,`
       `order_id,`
       `array_length(product_ids, 1) as order_size`
`FROM   t1`
`LEFT JOIN orders using(order_id)`
* **Задача:** Добавить информацию о заказах (через `order_id`), чтобы получить количество продуктов в каждом заказе (`array_length(product_ids, 1)`).*
*Внутренний подзапрос 3 (t3 и t4):*

`SELECT order_id,`
       `sum(price) as order_price`
`FROM   (SELECT order_id,`
               `product_ids,`
               `unnest(product_ids) as product_id`
        `FROM   orders`
        `WHERE  order_id not in (SELECT order_id`
                                `FROM   user_actions`
                                `WHERE  action = 'cancel_order')) t3`
`LEFT JOIN products using(product_id)`
`GROUP BY order_id`
* **Задача:** Здесь ты снова исключаешь отменённые заказы и распаковываешь массив `product_ids`, чтобы получить цену каждого товара из заказа. Затем агрегируешь данные на уровне заказа, суммируя цены товаров для получения полной стоимости заказа (`order_price`).
Внешний запрос:

`SELECT user_id,`
       `count(order_price) as orders_count,`
       `round(avg(order_size), 2) as avg_order_size,`
       `sum(order_price) as sum_order_value,`
       `round(avg(order_price), 2) as avg_order_value,`
       `min(order_price) as min_order_value,`
       `max(order_price) as max_order_value`
`FROM   t2`
`LEFT JOIN t4 using (order_id)`
`GROUP BY user_id`
`ORDER BY user_id`
`LIMIT 1000`

**Задача:** На этом этапе объединяются данные из двух источников:

- `t2` (информация о пользователях и количестве продуктов в заказе).
- `t4` (стоимость каждого заказа).

После объединения выполняются агрегатные функции, такие как `COUNT()`, `AVG()`, `SUM()`, `MIN()`, и `MAX()` для получения требуемых показателей.

### Как писать такие запросы по шагам:

1. **Фильтрация данных**: Начни с фильтрации данных. Например, тебе нужно исключить отменённые заказы.
    
    - Для этого лучше всего сначала выбрать заказы, которые не были отменены (как в подзапросе `t1`).
2. **Присоединение таблиц**: После фильтрации присоедини таблицы для получения нужной информации (как в подзапросе `t2`).
    
    - Важный момент: присоединение таблиц через `LEFT JOIN` позволяет тебе оставить заказы, даже если во второй таблице (например, `products`) нет данных.
3. **Агрегация данных**: Определи, какие агрегатные функции тебе нужны (среднее, сумма, количество) и выполняй их на уровне присоединённых данных (как в подзапросе `t4`).
    
4. **Финальный запрос**: В конечном запросе собери все данные вместе и проведи необходимые подсчёты.
    

### Советы:

- **Понимание данных:** Всегда начинай с понимания, какие данные в каждой таблице и как они связаны.
- **Фильтрация:** Выполняй фильтрацию как можно раньше, чтобы не обрабатывать ненужные строки.
- **Агрегация:** После объединения данных с помощью `JOIN` всегда проверяй, на каком уровне ты выполняешь агрегацию — на уровне заказов, пользователей, или товаров.

### Понимание кода:

1. Ты фильтруешь отменённые заказы.
2. Присоединяешь данные о заказах и продуктах, используя `LEFT JOIN`.
3. Вычисляешь средние значения и суммы с помощью агрегатных функций.

Запрос выглядит сложным, но шаг за шагом, фильтруя и объединяя данные, ты сможешь выстроить его логику.


Пояснение задачи 15
### Что требуется от запроса?

Задача — посчитать **ежедневную выручку** (`revenue`) по каждому дню, но **исключить отменённые заказы**. Это значит:

1. **Вывести дату (`date`) заказа.**
2. **Посчитать сумму всех заказов за каждый день** (выручку).
3. **Исключить отменённые заказы.**


*Внутренний подзапрос 1 (t1):*

`SELECT order_id,`
       `unnest(product_ids) as product_id`
`FROM   orders`

**Что делает:** Мы берём все заказы и распаковываем массив товаров (`product_ids`). Теперь каждый товар из заказа представлен отдельной строкой с идентификатором заказа (`order_id`).`
