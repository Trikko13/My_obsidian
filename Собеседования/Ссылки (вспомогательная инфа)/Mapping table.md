**Таблица сопоставления** (в оригинале — **mapping table**) в Greenplum и PostgreSQL — это структура, которая используется для управления памятью, и, в частности, для связи между страницами данных в памяти и их физическим местоположением на диске. Она позволяет системе эффективно находить данные, минимизируя количество обращений к диску, что особенно важно в условиях MPP-архитектуры Greenplum.

### Зачем нужна таблица сопоставления?

Когда данные запрашиваются в Greenplum:

- Они сначала считываются из буферной области в памяти (shared buffer), если они уже закэшированы там.
- Если данных нет в буфере, они считываются с диска и временно помещаются в shared buffer.

Таблица сопоставления помогает быстро определять, находятся ли нужные страницы данных в памяти, или их необходимо загрузить с диска.

### Пример работы таблицы сопоставления:

Предположим, Greenplum должен выполнить запрос к таблице `sales`. Запрашиваемая информация может уже находиться в буфере, или ее нужно будет подгрузить с диска:

1. **Поиск в таблице сопоставления**: Сначала система проверяет таблицу сопоставления, чтобы увидеть, находятся ли страницы с данными `sales` в памяти. Если да, она может сразу отправить данные процессу, обрабатывающему запрос, минуя чтение с диска.
    
2. **Чтение с диска при необходимости**: Если данных нет в памяти, таблица сопоставления указывает, где именно на диске расположены нужные страницы. Система загружает их с диска и размещает в буферной области памяти.
    
3. **Обновление таблицы сопоставления**: Если данные были загружены с диска, таблица сопоставления обновляется, чтобы указывать на новое расположение страниц в памяти.
    

### Важность таблицы сопоставления в Greenplum

В Greenplum, как и в PostgreSQL, эта структура помогает эффективно управлять данными в памяти и избегать лишних обращений к диску. Это критично для распределённых систем, таких как Greenplum, где чтение с диска на разных узлах может быть дорогой операцией.

### Итог

Таблица сопоставления — это своего рода "карта", которая связывает страницы данных на диске с их копиями в памяти. Она позволяет быстро находить данные, которые уже находятся в shared buffer, или определять, откуда на диске их нужно загрузить.


### Разделение понятий: таблица сопоставления, буферная область и диск

1. **Буферная область (shared buffer)**:
    
    - Это участок оперативной памяти, зарезервированный для хранения страниц данных, которые активно используются. В PostgreSQL и Greenplum каждая страница данных обычно составляет 8 КБ.
    - Буферная область помогает системе временно держать часто используемые страницы данных в памяти, чтобы избежать частых операций чтения с диска.
2. **Таблица сопоставления (mapping table)**:
    
    - Таблица сопоставления также находится в памяти и отслеживает, какие страницы данных находятся в буферной области.
    - В таблице сопоставления хранятся метаданные, указывающие, какие конкретные страницы данных из таблиц (например, блоки таблицы `sales`) в данный момент загружены в буферную область.
    - Она не хранит сами данные, а лишь ссылки на страницы в буфере, их идентификаторы, а также, возможно, информацию о времени последнего использования для управления кэшированием.
3. **Физический диск**:
    
    - Это основное хранилище, где находятся все данные. Когда данные запрашиваются впервые и их нет в буферной области, система обращается к диску для их загрузки.

### Пример первого обращения к данным

Рассмотрим, что происходит, когда мы запрашиваем данные, которые еще не были загружены в память:

1. **Первый запрос**:
    
    - Система проверяет таблицу сопоставления, чтобы узнать, находятся ли нужные страницы данных в буферной области.
    - Если запись отсутствует (данных нет в буфере), система понимает, что ей нужно обратиться к диску, чтобы загрузить данные.
2. **Чтение данных с диска**:
    
    - Система находит нужные страницы данных на диске с помощью файловой структуры, которая хранит все страницы с их физическими адресами.
    - Эти страницы загружаются в буферную область. Теперь данные доступны в памяти.
3. **Обновление таблицы сопоставления**:
    
    - После загрузки данных в буфер таблица сопоставления обновляется. В нее добавляется запись, указывающая, что страницы данных теперь находятся в буфере, и показывающая их текущее местоположение в буферной области.
4. **Повторный запрос**:
    
    - Если тот же запрос на данные выполняется снова, система снова проверяет таблицу сопоставления.
    - На этот раз она находит запись в таблице, указывающую, что страницы уже находятся в буферной области, и может сразу прочитать их из памяти, не обращаясь к диску.

### Как таблица сопоставления определяет местоположение страниц на диске?

- **Файловая структура и идентификаторы**: В PostgreSQL и Greenplum страницы данных идентифицируются уникальными идентификаторами — обычно это номер блока в файле, содержащем данные. Когда система впервые обращается к данным на диске, она считывает эти блоки, основываясь на физической файловой структуре, которую она может быстро отобразить на нужные страницы.
    
- **Таблица сопоставления не знает прямого местоположения на диске**: Она оперирует адресами в буферной области и кэширует указатели на данные, которые уже в памяти. Когда данных в буфере нет, система обращается к дисковой файловой системе с запросом прочитать конкретный блок по его физическому адресу.
    

### Пример для лучшего понимания

Допустим, мы делаем запрос к таблице `sales`, и нам нужны данные из страницы с блоком 15.

1. **Первый доступ**:
    
    - Таблица сопоставления пуста, так как запрос на блок 15 происходит впервые.
    - Система запрашивает блок 15 с диска. Данные этого блока загружаются в буферную область, и таблица сопоставления обновляется, чтобы указать, что блок 15 находится в памяти.
2. **Повторный доступ**:
    
    - Мы снова запрашиваем данные из блока 15. Система проверяет таблицу сопоставления, видит, что блок 15 уже находится в буферной области, и обращается к нему напрямую в памяти, без чтения с диска.

Таким образом, таблица сопоставления помогает оптимизировать доступ к данным, кэшируя информацию о расположении страниц в памяти и избавляя от необходимости каждый раз обращаться к диску.