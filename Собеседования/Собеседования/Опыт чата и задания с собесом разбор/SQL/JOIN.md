## Логические джоины
Left [outer] join – основной в работе, берёт все записи из левой таблицы и те записи из правой, которые совпадают по условию соединения. Колонки присоединяются справа, и можно через алиасы обращаться к обеим таблицам. Используется всегда, кроме случаев, когда нам важно полное сопоставление данных из двух таблиц и “дополнительная фильтрация” по условию соединения. Outer никто не пишет, но по стандарту можно.r
 

`select o.date, o.price, c.name` 
`from orders o` 
`left join clients c`
`on o.client_id = c.id`
  
Левая таблица находится в секции from, правая – джойнится к ней.
Грубо (логически) можно представлять, что сначала каждой строке сопоставляется каждая (полное декартово произведение), а потом происходит фильтрация по условию `on`.

Если левая таблица 10 строк, а правая таблица 5 строк:
Минимальное количество строк (если нет совпадений) = 10
Обычно (если значения пересекаются и не повторяются внутри одной таблицы, от 1 до 10 и от 1 до 5) = 10
Максимальное количество строк (если все строки совпадают и все значения равны друг другу) = 50

  
`with l as (`
  `select generate_series(1,10) / 11 as id /* all 0 */`
 `),`
 `r as (`
`select generate_series(1,5) / 6 as id /* all 0 */`
 `)`
 `select count(1)`
 `from l`
 `left join r on l.id = r.id;`
`**`

[Inner] join – похож на left join, но ещё и из основной, левой, таблицы отбрасывает данные, которые не джойнятся на данные из правой по условию `on`. Слово inner не обязательно.

Если левая таблица 10 строк, а правая таблица 5 строк:

Мин = 0
Обычно = 5
Макс = 50
**

Визуализация ,Почему 50 при LEFT JOIN  если везде 0 - https://dataschool.com/how-to-teach-people-sql/left-right-join-animated/


**

Cross join – единственный джоин без условия, все строки со всеми, полное декартово произведение. Применяется, когда нужно каждой строке из календаря, мелкого справочника или другой структуры с константами сопоставить каждую строку из основной таблицы.
  
Если левая таблица 10 строк, а правая таблица 5 строк:
Мин = 50
Макс = 50

  
Self join – любой джоин, где левая и правая таблица это та же самая таблица. Обязательны алиасы для указания, какая колонка к какой таблице относится. Применяется для сопоставления строк по неравенству (>=, !=) или раскручивания иерархии (типовая таблица employee_manager с полем manager_id, который тоже является employee и имеет свой employee_id).

  
Anti join – любой джоин, в результате которого остаются только записи, для которых не нашлось пары в другой таблице. Пример реализации ниже

```
select l.*
from l
join r on l.id = r.id
where r.id is null
```
Давай представим типы `JOIN` с ассоциациями, которые помогут интуитивно представить, что происходит при каждом из них. Представь, что у нас есть два списка гостей для разных мероприятий, и мы хотим найти пересечения, объединения и разные связи между этими списками.

### Ассоциации для `JOIN` в SQL

1. **INNER JOIN** — "Общие друзья"
    
    - Представь, что у тебя есть два списка гостей, приглашённых на два разных мероприятия (списки `A` и `B`).
    - `INNER JOIN` — это как попросить всех гостей из списка `A` прийти только в том случае, если они также приглашены в списке `B`, и наоборот. В результате остаются только "общие друзья", те, кто есть в обоих списках.
    - **Ассоциация**: "Кто был приглашён на оба мероприятия?"
2. **LEFT JOIN** — "Моя вечеринка + возможно, их гости"
    
    - В этом случае список `A` — твоя вечеринка, а `B` — вечеринка твоего друга. Ты приглашаешь всех из списка `A`, независимо от того, пойдут ли они на вечеринку друга.
    - Если человек из твоего списка `A` также есть в списке `B`, он приходит с другом. Если нет, он всё равно приглашён и приходит один.
    - **Ассоциация**: "Кого я пригласил и кто ещё приглашён на вечеринку друга?"
3. **RIGHT JOIN** — "Их вечеринка + возможно, мои гости"
    
    - То же самое, что и `LEFT JOIN`, но теперь основа — список `B` (вечеринка друга). Все, кто есть в `B`, приглашены, и к ним добавляются те, кто также присутствует в `A`. Если гости из `B` есть и в `A`, они приходят с твоей вечеринки.
    - **Ассоциация**: "Кого пригласил друг и кто из них приглашён на мою вечеринку?"
4. **FULL JOIN** — "Большая вечеринка для всех"
    
    - Здесь обе вечеринки объединяются. Если кто-то есть в обоих списках, он приходит как общий друг, если только в одном из списков — он тоже приглашён.
    - В результате ты получаешь полный список всех гостей, даже если они были приглашены только на одну из вечеринок.
    - **Ассоциация**: "Полный список всех, кто был приглашён на любую из вечеринок."
5. **CROSS JOIN** — "Каждый с каждым"
    
    - Представь, что каждый гость из списка `A` встречается и взаимодействует с каждым гостем из списка `B`. Здесь вообще не важно, есть ли у них общие друзья или связи — каждый встречается с каждым.
    - **Ассоциация**: "Каждое возможное сочетание гостей с двух вечеринок."

### Резюме ассоциаций:

- **INNER JOIN**: общие друзья.
- **LEFT JOIN**: моя вечеринка + друзья, если они у друга.
- **RIGHT JOIN**: их вечеринка + мои друзья, если они у меня.
- **FULL JOIN**: вечеринка для всех.
- **CROSS JOIN**: каждый с каждым, не важно, знакомы ли они.

Эти ассоциации помогают интуитивно представить, что остаётся в итоговом результате каждого `JOIN`, и проще представить конечный результат.

## Физические джоины

Hash join — экви-джоин (строго по равенству) большой и маленькой таблицы. Маленькая помещается в память, ключи обеих таблиц хэшируются, один раз проходим по большой таблице и один раз по маленькой. O(m+n) по времени + O(n) по памяти

  
Sort merge join — экви-джоин двух больших таблиц, которые не помещаются в память. Сортируем по ключу и проходимся "замочком", состёгивая две таблицы вместе. Если сортировка проводится за O(n*log(n)), то O (n*log(n) + m*log(m) + n + m) -> (n+m) схлопываются как незначительные, получаем O(n*log(n)) + m*log(m)). В заранее отсортированных массивах O(m+n)

Визуализация: [https://bertwagner.com/posts/visualizing-merge-join-internals-and-understanding-their-implications/?ref=yuji.page](https://bertwagner.com/posts/visualizing-merge-join-internals-and-understanding-their-implications/?ref=yuji.page) 

  Nested loop — все остальные джоины ( a.id >= b.id, a.id like '%word%' и прочие != ), каждое значение левой таблицы сопоставляем со значением из правой таблицы (аналог CROSS JOIN), сложность O(n*m). Визуализировать можно через вложенные циклы

  

for a in list_a:

  for b in list_b:

....

  

Может выбираться при экви-джоине, если сортировка таблицы займёт больше времени:

. отбираемые колонки покрыты составными индексами в обеих таблицах

. фильтр оставляет мало записей в каждой таблице

. параллельная обработка вложенным циклом на каждом сегменте может быть быстрее сортировки

  

Для этого нужна актуальная статистика по таблицам (после каждой крупной операции вставки/изменения прогонять ANALYZE table;

**