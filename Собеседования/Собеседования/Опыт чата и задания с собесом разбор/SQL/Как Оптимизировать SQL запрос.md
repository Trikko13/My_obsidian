(Вернутся после Гринплам)

Основная идея – обрабатывать как можно меньше данных (фильтровать раньше). Достигается через pushdown filter (пробрасывание where на системы-источники в случае федеративных систем/ETL систем или в таблицы-источники в случае использования view/функций в БД), через индексы в OLTP, через партиции (реже – кластеры) в OLAP, распределение в MPP системе по шардам равномерно (вся упряжка бежит со скоростью самой медленной лошадки). Также в MPP стоит минимизировать shuffle, где возможно (не менять ключ распределения и сортировку на каждом шаге расчёта витрин, использовать broadcast join для справочников).

  
Любят спрашивать про чтение план запроса. Волшебные слова: через EXPLAIN ANALYZE смотрим план, ищем нехорошие слова (nested loop, shuffle, table scan – игнорирование индекса). Радуемся, когда видим хорошие hash join, merge join, index seek (использование индекса).

  
Для Greenplum нужно минимизировать количество спиллов (сохранение данных на диск, когда они не помещаются в памяти), слайсов (каждый слайс это перемещение данных по сети) и выполнения операций на мастере (gather motion n:1),  
где n – число сегментов.

**### **Базовые принципы оптимизации SQL**

1. **Сначала фильтруй, потом группируй:**
    
    - Пример:
        
        
        `SELECT category, SUM(sales) FROM orders WHERE order_date > '2023-01-01' GROUP BY category;`
        
        Фильтр по дате уменьшает объём данных для группировки.
2. **Сначала фильтруй, потом джойнь:**
    
    - Пример:
        
        
        `SELECT c.customer_name, o.total FROM customers c JOIN orders o ON c.customer_id = o.customer_id WHERE o.order_date > '2023-01-01';`
        
        Фильтрация по дате до джойна ускоряет выполнение.
3. **Equi join, без преобразований:**
    
    - Используй строгие равенства (`=`) в джоинах:
        
        
        `SELECT *  FROM customers c JOIN orders o ON c.customer_id = o.customer_id;`
        
4. **`IN` только для маленьких множеств:**
    
    - Используй `IN` для небольших списков (до 100-200 значений):

        `SELECT *  FROM products WHERE category_id IN (1, 2, 3);`
        
5. **Избегай `UNION`:**
        
6. **Подзапросы требуют особого внимания:**
    
    - Иногда лучше заменить подзапросы на **CTE** или джойны.
    - Пример CTE:
        
        `WITH recent_orders AS (     SELECT * FROM orders WHERE order_date > '2023-01-01' ) SELECT customer_id, SUM(total)  FROM recent_orders GROUP BY customer_id;`
        
7. **Не злоупотребляй оконными функциями:**
    
    - Если задачу можно решить через агрегацию, избегай `LEAD`, `LAG`:
        
        `SELECT customer_id, SUM(total) FROM orders GROUP BY customer_id;`
        
8. **Индексы и партиции:**
    
    - Индексы важны, но не переборщи: оптимизируй только нужные поля.
    - Пример индекса:
        
        
        `CREATE INDEX idx_order_date ON orders (order_date);`
        
    - Используй партиционирование для больших таблиц:
        
        `CREATE TABLE orders_2023 PARTITION OF orders FOR VALUES FROM ('2023-01-01') TO ('2024-01-01');`
        
9. **`ORDER BY` — дорогая операция:**
    
    - Если нужен быстрый результат, избегай сортировки.
    - Или добавь индекс для ускорения:
        
        `CREATE INDEX idx_total ON orders (total);`
        
10. **COUNT(DISTINCT):**
    
    - Для больших данных используй приближённый подсчёт:
        
        `SELECT COUNT(*) FROM (     SELECT DISTINCT customer_id FROM orders ) subquery;`
        
11. **Никакой преждевременной оптимизации!**
    
    - Сначала анализируй реальный план выполнения через `EXPLAIN ANALYZE`.
    - Оптимизируй только узкие места.