## Карпов. 1 задача из 2 блока 
![[Карпов 1.png]]### Разбор решения

1. **Основная идея**:
    
    - Автор использует вложенные подзапросы, чтобы сосредоточиться на ключевых задачах:
        - Определение минимальной даты для каждого пользователя/курьера.
        - Группировка по дате и подсчёт новых пользователей/курьеров для каждой даты.
        - Объединение результатов через `LEFT JOIN` для формирования итоговой таблицы.
    - Накопительные суммы (`total_users` и `total_couriers`) вычисляются в самом внешнем запросе с использованием оконных функций.
2. **Структура запроса**:
    
    - Два подзапроса:
        - Один подсчитывает новых курьеров (`new_couriers`).
        - Другой подсчитывает новых пользователей (`new_users`).
    - Эти два результата соединяются через `LEFT JOIN` на `start_date`.

## Карпов. 1 задача из 2 блока 

![[карпов 2.png]]
### ниверсальная инструкция движения от подзапросов наружу

1. **Начни с минимально необходимых данных**:
    
    - Определи ключевые данные, которые нужно агрегировать или извлечь.
    - Если задача связана с минимальными/максимальными датами, первым шагом будет определение таких значений:
            
        `SELECT user_id, MIN(time::date) AS first_action_date FROM user_actions GROUP BY user_id;`
        
2. **Группировка данных на следующем уровне**:
    
    - Группируй данные по ключевым значениям, полученным на первом этапе, и подсчитывай метрики, такие как `COUNT`, `SUM` и т.д.:
        
        
        `SELECT first_action_date AS date, COUNT(*) AS new_users 
        `FROM first_actions 
        `GROUP BY first_action_date;`
        
    - Этот шаг превращает сырые данные в агрегированные.
3. **Объединение всех необходимых таблиц**:
    
    - Подумай, какие данные из подзапросов нужно объединить в единый результат.
    - Обычно для объединения используется ключ, общий для всех подзапросов (например, дата):
                
        `SELECT d.date, dnu.new_users, dnc.new_couriers 
        `FROM dates d 
        `LEFT JOIN daily_new_users dnu USING (date) 
        `LEFT JOIN daily_new_couriers dnc USING (date);`
        
4. **Используй вложенные подзапросы для группировки и объединения**:
    
    - Объединяй данные через подзапросы, чтобы минимизировать количество этапов:
        
        `SELECT date,         
		    `COUNT(user_id) AS new_users 
		`FROM (SELECT user_id, MIN(time::date) AS date       
			`FROM user_actions       
			`GROUP BY user_id) t1 
		`GROUP BY date;`
        
5. **Рассчитай накопительные метрики через оконные функции**:
    
    - После получения новых пользователей/курьеров рассчитывай накопительные значения с помощью оконных функций:
        
        `SELECT date,         
	        `SUM(new_users) OVER (ORDER BY date) AS total_users 
	    `FROM daily_totals;`
        
6. **Применяй `LAG` и другие оконные функции в финальном запросе**:
    
    - Оконные функции, такие как `LAG`, используются для сравнения значений между строками (например, приросты):
        

        `SELECT date,       
	        `` new_users,       
	        `` LAG(new_users) OVER (ORDER BY date) AS previous_new_users
		`` FROM daily_totals;`
        
7. **Выполняй расчёты на последнем этапе**:
    
    - Финальные расчёты, такие как процентные изменения, лучше выполнять в самом внешнем запросе, чтобы избежать сложности:
        
        `SELECT date,        ROUND(100 * (new_users - previous_new_users) / previous_new_users, 2) AS new_users_growth FROM growth_calculations;`
        
8.  **Минимизируй использование промежуточных таблиц и CTE**:
    
    - Старайся объединять шаги там, где это возможно, используя вложенные подзапросы вместо CTE:
        
        `SELECT date,        
		    `COUNT(user_id) AS new_users 
		`FROM (SELECT user_id, MIN(time::date) AS date       
			`FROM user_actions       
			`GROUP BY user_id) t1 GROUP BY date;`
        
9. **Проверяй структуру на каждом этапе**:
    
    - Убедись, что данные на каждом этапе являются логичными и содержат только необходимую информацию.
    - Для этого выполняй подзапросы по отдельности.
10. **Тестируй запрос поэтапно**:
    
    - Выполняй запросы от внутренних к внешним, проверяя, правильно ли рассчитаны промежуточные метрики.

### Основные рекомендации

1. **Работай от результата**:
    
    - Представь финальный результат, какие данные в нём должны быть, и разложи их на составные части.
2. **Не дублируй расчёты**:
    
    - Убедись, что каждая метрика считается только один раз. Например, накопительные значения (`total_users`) считаются сразу, чтобы их не пересчитывать в отдельном CTE.
3. **Минимизируй уровни вложенности**:
    
    - Используй `JOIN` вместо дополнительных уровней вложенных подзапросов, если это возможно.
4. **Считай сложные метрики на последнем этапе**:
    
    - Используй `LAG`, `LEAD`, и другие оконные функции в финальном запросе.
5. **Сохраняй читаемость**:
    
    - Убирай ненужные шаги, чтобы запрос оставался понятным.
