#циан#cian
#### 1. Какие используешь подходы для расширения логики в коде?
- **Композиция:**
    - Код легче тестировать.
    - Более гибкая структура (можно менять логику без изменения всей иерархии).
- **Наследование:**
    - Подходит для структур с сильной связью (например, классы животных: `Animal -> Dog -> Poodle`).
    - Минус: затрудняет рефакторинг и может привести к сильной связанности.

#### **2. Python: immutable vs mutable**

- **Immutable (неизменяемые):** `int`, `float`, `str`, `tuple`.
    - Нельзя изменить после создания.
    - Безопасны для использования в многопоточности.
- **Mutable (изменяемые):** `list`, `dict`, `set`.
    - Можно изменять после создания.
    - Могут быть причиной неожиданных багов, если используются как аргументы функций.


#### **3. Можем ли использовать в качестве ключа словаря инстанс класса?**

- Да, если класс реализует методы `__hash__` и `__eq__`.  

class MyClass:
    def __init__(self, value):
        self.value = value

    def __hash__(self):
        return hash(self.value)

    def __eq__(self, other):
        return self.value == other.value


#### **4. Что выведет код и почему?**

def func(a: int, b: list[int] = []):
    b.append(a)
    print(b)

func(1)
func(2)


**Почему:**  
Список `b` инициализируется **один раз при определении функции**.  
При последующих вызовах функции используется этот же объект.

def func(a: int, b: list[int] = None):
    if b is None:
        b = []
    b.append(a)
    print(b)

#### **5. В какой момент происходит инициализация объекта для дефолтного значения?**

- Инициализация происходит **при определении функции** (то есть при чтении модуля).  
    Это может вызвать неожиданные баги для изменяемых объектов.

#### **6. Почему плохо передавать “тяжёлый” класс как параметр?**

def __init__(client: Client = Client()):
    ...
**Проблемы:**

- Объект создаётся при импорте модуля, а не при вызове конструктора.
- Тяжёлые классы (например, с сетью или большими данными) увеличивают время импорта.