### Как работает **Nested Loop Join**:

1. **Основная идея**:
    
    - Один из наборов данных (`таблица 1`) выступает как внешний цикл.
    - Для каждой строки из внешнего набора данных SQL-система последовательно перебирает строки из внутреннего набора данных (`таблица 2`), чтобы найти соответствие по ключу соединения.
    - Этот процесс эффективен только для небольших наборов данных или при использовании индекса.
2. **Производительность**:
    
    - В наихудшем случае сложность алгоритма — **O(N × M)**, где `N` и `M` — количество строк в таблицах.
    - Без индекса или сортировки процесс может быть очень медленным для больших таблиц.
3. **Индексация**:
    
    - Если внутренняя таблица отсортирована по ключу соединения или имеет индекс (например, B-tree), поиск соответствий становится гораздо быстрее, поскольку система может использовать бинарный поиск вместо последовательного перебора.
### Как сортировка может ускорить Nested Loop Join:

Сортировка может помочь в нескольких сценариях:

1. **Использование индекса**:
    
    - Если внутренняя таблица отсортирована по ключу соединения, база данных может быстрее находить строки с помощью индексации.
    - Например, для соединения по `id`, индексированный поиск может сократить количество операций.
2. **Сортировка внешней таблицы**:
    
    - Если обе таблицы отсортированы по ключу соединения, перебор строк становится более последовательным и эффективным.
3. **Пример сортировки**:
    
    - Для ускорения NLJ можно предварительно отсортировать обе таблицы:
        
        
        `SELECT *
    - ``  FROM (     
        - `SELECT * FROM table1 ORDER BY join_key 
        - `) t1 
        - `JOIN ( 
        - ``    SELECT * FROM table2 ORDER BY join_key 
        - `) t2 
        - `ON t1.join_key = t2.join_key;`
            
    - Такая сортировка помогает SQL-оптимизатору быстрее находить соответствия.