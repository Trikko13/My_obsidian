### Как работает **Nested Loop Join**:

1. **Основная идея**:
    
    - Один из наборов данных (`таблица 1`) выступает как внешний цикл./
    - Для каждой строки из внешнего набора данных SQL-система последовательно перебирает строки из внутреннего набора данных (`таблица 2`), чтобы найти соответствие по ключу соединения.
    - Этот процесс эффективен только для небольших наборов данных или при использовании индекса.
2. **Производительность**:
    
    - В наихудшем случае сложность алгоритма — **O(N × M)**, где `N` и `M` — количество строк в таблицах.
    - Без индекса или сортировки процесс может быть очень медленным для больших таблиц.
3. **Индексация**:
    
    - Если внутренняя таблица отсортирована по ключу соединения или имеет индекс (например, B-tree), поиск соответствий становится гораздо быстрее, поскольку система может использовать бинарный поиск вместо последовательного перебора.
### Как сортировка может ускорить Nested Loop Join:

Сортировка может помочь в нескольких сценариях:

1. **Использование индекса**:
    
    - Если внутренняя таблица отсортирована по ключу соединения, база данных может быстрее находить строки с помощью индексации.
    - Например, для соединения по `id`, индексированный поиск может сократить количество операций.
2. **Сортировка внешней таблицы**:
    
    - Если обе таблицы отсортированы по ключу соединения, перебор строк становится более последовательным и эффективным.
3. **Пример сортировки**:
    
    - Для ускорения NLJ можно предварительно отсортировать обе таблицы:
        
        
        `SELECT *
    - ``  FROM (     
        - `SELECT * FROM table1 ORDER BY join_key 
        - `) t1 
        - `JOIN ( 
        - ``    SELECT * FROM table2 ORDER BY join_key 
        - `) t2 
        - `ON t1.join_key = t2.join_key;`
            
    - Такая сортировка помогает SQL-оптимизатору быстрее находить соответствия.

### Когда используется Nested Loop Join:

1. **Маленькие таблицы**:
    
    - Если одна из таблиц маленькая, Nested Loop Join будет вполне эффективен даже без индексов.
2. **Фильтрация**:
    
    - Если к одной из таблиц применяются фильтры, которые существенно уменьшают её размер, NLJ может стать выгодным выбором.
3. **Отсутствие индексов**:
    
    - Когда на ключе соединения нет индексации, NLJ может быть единственным вариантом, хотя это медленно.
### Альтернативы Nested Loop Join:

1. **Hash Join**:
    
    - Таблицы хэшируются по ключу соединения. Это быстрее для больших несортированных таблиц.
    - Например, используется в Spark и многих MPP-системах.
2. **Merge Join**:
    
    - Требует предварительной сортировки обеих таблиц.
    - После сортировки строки объединяются последовательным перебором, что делает этот метод гораздо быстрее для больших наборов данных.
### Как узнать, какой физический джойн используется?

Ты можешь посмотреть план выполнения запроса, чтобы узнать, какой физический джойн был выбран.

#### Пример в PostgreSQL:


`EXPLAIN ANALYZE 
`SELECT * 
`FROM (     
	`SELECT * FROM table1 ORDER BY join_key 
`) t1 
`JOIN ( 
	`SELECT * F ROM table2 ORDER BY join_key 
`) t2 
`ON t1.join_key = t2.join_key;`

**Вывод плана выполнения (`EXPLAIN`)**:

- В выводе будет указано, какой тип джойна был использован: `Nested Loop Join`, `Hash Join`, `Merge Join`.

### Пример поведения:

#### Nested Loop Join:

- Используется, если:
    - Одна таблица маленькая.
    - Нет индексов.
    - Подходит для фильтрации небольшого количества данных.

#### Hash Join:

- Используется, если:
    - Таблицы несортированы.
    - Таблицы большие.
    - Подходит для больших данных, где нельзя заранее отсортировать.

#### Merge Join:

- Используется, если:
    - Обе таблицы отсортированы по ключу.
    - Можно выполнять последовательный доступ.