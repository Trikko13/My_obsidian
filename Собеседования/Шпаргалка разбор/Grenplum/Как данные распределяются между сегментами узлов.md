В Greenplum данные физически хранятся на сегментных узлах. Каждый сегмент отвечает за свою часть данных, и мастер-узел управляет их распределением. Для этого используется ключевой механизм — **ключ дистрибуции (distribution key)**.

#### 1. **Distribution Key (ключ дистрибуции)**:

- Ключ дистрибуции — это один или несколько столбцов таблицы, которые определяют, на каком сегменте будут храниться данные.
- Когда данные добавляются в таблицу, Greenplum вычисляет хэш на основе значений ключа дистрибуции. Результат хэша определяет, какой сегмент будет хранить данные.

#### 2. **Хэш-распределение**:

- Данные распределяются между сегментами с помощью хэш-функции, которая обеспечивает равномерное распределение. Это минимизирует дисбаланс нагрузки между сегментами.
- Если ключ дистрибуции выбран правильно, данные распределяются равномерно, и все сегменты работают с одинаковой нагрузкой.

#### 3. **Блоки хранения данных**:

- После распределения данные на сегменте хранятся в виде блоков (обычно по 8 КБ), организованных так же, как в PostgreSQL.

---

### **Типы распределения данных**

Greenplum поддерживает два основных типа распределения данных:

1. **HASH** (распределение по хэшу):
    
    - Это наиболее часто используемый метод.
    - Данные распределяются на основе хэш-значений ключа дистрибуции.
    - Пример:
        `CREATE TABLE sales (     sale_id INT,     region_id INT,     amount NUMERIC ) DISTRIBUTED BY (region_id);`
        
        Здесь данные распределяются между сегментами на основе значения `region_id`.
2. **RANDOM** (случайное распределение):
    
    - Данные распределяются случайным образом без использования хэш-функции.
    - Этот метод подходит, если у таблицы нет очевидного ключа дистрибуции.
    - Пример:
         
        `CREATE TABLE sales (     sale_id INT,     region_id INT,     amount NUMERIC ) DISTRIBUTED RANDOMLY;`
        

### **Проблемы неправильного распределения данных**

1. **Дисбаланс сегментов**:
    
    - Если ключ дистрибуции выбран неправильно (например, значения имеют низкую кардинальность), данные могут оказаться неравномерно распределёнными между сегментами. Это приводит к тому, что некоторые сегменты перегружены, а другие почти не используются.
2. **Кросс-сегментные операции**:
    
    - Если таблицы для `JOIN` или `GROUP BY` распределены по разным ключам, Greenplum вынужден перераспределять данные между сегментами, что может сильно замедлить запрос.

---

### **Как выбрать ключ дистрибуции?**

Хороший ключ дистрибуции должен:

1. **Иметь высокую кардинальность** (много уникальных значений), чтобы данные распределялись равномерно.
2. **Быть часто используемым в запросах JOIN или GROUP BY**, чтобы минимизировать кросс-сегментные операции.
3. **Не содержать NULL**, так как это может создавать дополнительные накладные расходы.

Пример хорошего выбора:

- Для таблицы `orders` ключ дистрибуции `order_id` может быть хорошим выбором, если каждый заказ уникален и запрашивается отдельно.
- Для таблицы `sales` можно выбрать `region_id`, если запросы часто группируются по регионам.

### **Пример на практике**

#### Создание таблицы:

`CREATE TABLE customer_orders (
	`order_id INT,    
	`customer_id INT,     
	`product_id INT,     
	`amount NUMERIC 
`) 
`DISTRIBUTED BY (customer_id);

- Здесь данные распределяются по `customer_id`.
- Если данные добавляются:
    
    `INSERT INTO customer_orders VALUES (1, 101, 1001, 200.00);`
    Greenplum вычисляет хэш для `customer_id = 101` и определяет, на каком сегменте хранить запись.

#### Проблема:

Если вы решите распределять данные по `order_id`, но в запросах часто используются `customer_id` для группировок или `JOIN`, это приведёт к дополнительной пересылке данных между сегментами.

---
### Итог:

- **Распределение данных — ключевой механизм Greenplum**, который определяет производительность запросов.
- **Выбор правильного ключа дистрибуции** — это основа оптимизации запросов и равномерной загрузки сегментов.
- **Плохой выбор ключа дистрибуции** приводит к перегрузке сегментов и замедлению запросов.

Высокая кардинальность ключей дистрибуции повышает эффективность при добавлении новых сегментов и убирает риск неравномерной нагрузки. Так же убирает вероятность hotspost при сильном перекосе объема данных в одном ключе (допустим если region_id=1 встречается в 80% случаях) .